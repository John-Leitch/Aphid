using Components.External.ConsolePlus;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Security;
using System.Security.Permissions;
using System.Security.Policy;


var sandbox = { root: null, bin: null };
sandbox.exec = @(userScript) {
    var sandboxRoot = sandbox.root ?? Assembly.GetExecutingAssembly().Location |> Path.GetDirectoryName;
    var sandboxDir = Path.Combine(sandboxRoot, 'Sandbox', Guid.NewGuid().ToString());

    if (!Directory.Exists(sandboxDir)) {
        Directory.CreateDirectory(sandboxDir);
    }

    var getSandboxPath = @() $args |> Path.Combine @Path.Combine(sandboxDir);    
    var sandboxExe = 'Aphid.exe' |> getSandboxPath;
    
    var getBin = @() sandbox.bin == null ?
        ($($args.Count) 0: getEntryPath(), 1: getEntryPath($args[0]), getEntryPath($args)) :
        Path.Combine(sandbox.bin, $args @String.Join('\\'));
    
Enumerable.Concat(
        [ 'Aphid.exe','Aphid.exe.config', 'Components.Aphid.dll', 'Components.Aphid.dll.config' ]->getBin,
        [ 'Library' ]->getBin-<@() Directory.GetFiles($_, '*', SearchOption.AllDirectories))
    ->(@() [ $_, $_.Substring(getBin().Length + 1) |> getSandboxPath ])
    ->(@(x) {
        x[1] |> Path.GetDirectoryName |> Directory.CreateDirectory;
Cli.WriteLine("Copying {0} to {1}", x[0], x[1]);
        File.Copy(x[0], x[1]);
    });

    var dst = Path.GetFileName(userScript) |> getSandboxPath;
Cli.WriteLine('Configuring user script {0}', dst);

    File.Move(userScript, dst);
Cli.WriteLine('Configuring permissionts');
    var ps = new PermissionSet(PermissionState.None);

    [ 
        new SecurityPermission(SecurityPermissionFlag.Execution |
            SecurityPermissionFlag.UnmanagedCode),
        new ReflectionPermission(ReflectionPermissionFlag.RestrictedMemberAccess),
        new FileIOPermission(FileIOPermissionAccess.AllAccess, sandboxDir),
        new EnvironmentPermission(PermissionState.Unrestricted),
        new UIPermission(PermissionState.Unrestricted),
    ]->ps.AddPermission;


    var evidence = new Evidence([ new Zone(SecurityZone.Internet) ], []);
Cli.WriteLine('Creating appdomain');
    var ads = new AppDomainSetup();
    ads.ApplicationBase = sandboxDir;
    var ad = AppDomain.CreateDomain('Sandbox', evidence, ads, ps, []);

Cli.WriteLine('Unwrapping\r\n\t{0}\r\n\t{1}',         RemoteConsoleListener.Assembly.FullName, RemoteConsoleListener.FullName);    
    var proxy = ad.CreateInstanceAndUnwrap(
        RemoteConsoleListener.Assembly.FullName,
        RemoteConsoleListener.FullName);

    proxy.SetOut();
    var oldCwd = Directory.GetCurrentDirectory();
Cli.WriteLine('Old cwd: {0}', oldCwd);
    sandboxDir |> Directory.SetCurrentDirectory;
Cli.WriteLine('Sandbox working dir: {0}', sandboxDir);

    //Console.WriteLine('Executing sandboxed code');
Cli.WriteLine('Sandbox appdomain: {0}', ad);

Cli.WriteLine('Sandbox exe: {0}', sandboxExe);

Cli.WriteLine('Sandbox exe exists: {0}', File.Exists(sandboxExe));
Cli.WriteLine('Sandbox script: {0}', dst);
Cli.WriteLine('Sandbox script exists: {0}', File.Exists(dst));


    ad.ExecuteAssembly(sandboxExe, [ dst ]);
    // Console.WriteLine('Done Executing sandboxed code');
    proxy.Flush() |> Console.Write;
    ad |> AppDomain.Unload;
    oldCwd |> Directory.SetCurrentDirectory;
    Directory.Delete(sandboxDir, true);
};

sandbox.eval = @(code) {
    var tmp = Guid.NewGuid().ToString() @String.Format("Sandboxed_{0}.alx");
    var tmpFull = sandbox.root == null ? (tmp |> getExecutingPath) : Path.Combine(sandbox.root, tmp);
    
    if (!Directory.Exists(sandbox.root)) {
        Directory.CreateDirectory(sandbox.root);
    }
    // Console.WriteLine('Writing sandbox script to {0}', tmpFull);
    File.WriteAllText(tmpFull, code);    
    tmpFull |> sandbox.exec;
    File.Delete(tmpFull);
};