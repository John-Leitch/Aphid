var stdio;

@{
    var traceLevel = 3;

    trace = macro(@(l, m){
        if (traceLevel >= l) {
            print('[~Cyan~{0:x4}~R~] {1}' :: [ Thread.CurrentThread.ManagedThreadId, m ]);
        }
    });

    stdio = {
        reader: @(pipe, bufferSize) ({
            bufferSize: bufferSize defined ? bufferSize : 0x100,
            buffer: Array.CreateInstance(char, bufferSize),
            read: @(callback){
                var charsRead = 0;
                var lastPeek = 0;
                while (pipe.Peek() > -1 //&&
                    // (charsRead = pipe.Read(buffer, 0, bufferSize)) != 0) {
                ){
                    charsRead = pipe.Read(buffer, 0, bufferSize);
                    trace(3, 'reader.read: data received');
                    callback(new string(buffer, 0, charsRead));
                    trace(4, 'reader.read: succeeded');

                    ret true;                
                }

                trace(4, 'reader.read: failed');

                ret false;
            },        
        }),
        redirect: @(process, callback) {            
            var data = new List[Object]();
            
            var reset = redirectAsync(
                process,
                @(data, isError, context) {
                    trace(2, 'redirect: data received');
                    lock context context.Add($args);
                    trace(3, 'redirect: data added');
                },
                data);
            
            do {
                trace(4, 'redirect: waiting on event');
                reset.WaitOne();
                trace(4, 'redirect: event set');
                var tmp;
                
                lock data {
                    tmp = data.ToArray();
                    data.Clear();
                }

                trace(4, 'redirect: callback started');
                tmp for callback($_[0], $_[1]);
                trace(4, 'redirect: callback finished');
                process.Refresh();
            } while (!process.HasExited || !reset.SafeWaitHandle.IsClosed);

            trace(1, 'redirect: waiting for exit');
            process.WaitForExit();
            trace(1, 'redirect: done waiting for exit');

            if (data.Count > 0) {
                trace(2, 'redirect: handling remaining data');
                data for callback($_[0], $_[1]);
            }

            trace(0, 'redirect: finished');
        },
        pipeName: @(process, pipe) process.StandardOutput == pipe ? 'stdout' : 'stderr',
        redirectAsync: @(process, callback, context) {
            trace(0, 'redirectAsync: started');
            var reset = new AutoResetEvent(false);
            var tasks = [ [process.StandardOutput, false], [process.StandardError, true] ]
                ->@(p) bufferPipeAsync(
                    process,
                    p[0],
                    @(x) {
                        trace(2, 'redirectAsync: ~Magenta~{0}~R~ data received ({1:n0} bytes)' ::[ pipeName(process, p[0]), x.Length]);
                        callback(x, p[1], context);
                        trace(2, 'redirectAsync: ~Magenta~{0}~R~ event set' :: pipeName(process, p[0]));
                        reset.Set();
                    });

            @{ 
                trace(1, 'redirectAsync: disposing reset started');
                reset.Set();
                reset.Dispose();
                trace(0, 'redirectAsync: done');
            }
            @when.all(tasks);
            
            ret reset;
        },
        bufferPipeAsync = @(process, pipe, callback)
            async.long(@{
                trace(0, 'bufferPipeAsync: started watching ~Magenta~{0}~R~' :: pipeName(process, pipe));                
                var pipeReader = stdio.reader(pipe);

                do {
                    trace(5, 'bufferPipeAsync: read started on {0}' :: pipe);
                } while (pipeReader.read(callback) || !process.HasExited);

                trace(0, 'bufferPipeAsync: finished for {0}' :: pipe);
            }),
    };
}();

// var outReader = stdio.reader(stdOut);
// var errReader = stdio.reader(stdErr);

// async.long(@{
//     do {
//         Console.WriteLine('Out redirection started');
//         if (!outReader.read(Console.Write)) {
//             // p.Refresh();
//         }
//     } while (!p.HasExited);

//     Console.WriteLine('Out redirection finished');
// });

// bufferPipeAsync(stdOut, Console.Write);
// bufferPipeAsync(stdErr, Console.Write);