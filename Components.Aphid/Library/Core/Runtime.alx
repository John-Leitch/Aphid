var runtime;

_trace = macro(@(handlerName) {
    @{
        var state = this.'$aphid' | this.'$internal'.initTrace;
        
        state.aphid.handlerName = @(x) {
            var o = options;

            if ((o.typeFilter != null && x.Expression.Type != o.typeFilter) ||
                (o.predicate != null && !o.predicate(x))) {
                ret null;
            }

            var sb = state.out;
            var hl = state.highlight;                    
            var file = x.Expression.Context.Filename;
            var index = x.Expression.Index;
            sb.Clear();
            sb.Append('[');

            if (o.showFilename)
            {
                if (file != null)
                {
                    sb.Append(file);
                }
                else
                {
                    sb.Append('$No File');
                }
            }

            if (o.calculatePosition && file != null)
            {
                var pos = state.posMemoizer.Call(
                    @(t) state.getPos(state.readScript(t.Item1), t.Item2),
                    new Tuple[string, int](file, index));                        

                if (pos != null) {
                    sb.AppendFormat(', line {0:n0}, column {1:n0}', pos.Item1, pos.Item2);
                } else {
                    sb.AppendFormat(', line {0}, column {0}', 'Error calculating position, unknown');
                }
            }

            if (o.showOffset)
            {
                sb.AppendFormat(', offset {0:n0}', index);
            }

            if (o.syntaxHighlighting)
            {
                sb.AppendFormat(
                    ']\r\n{0}\r\n',
                    hl(x.Expression));
            }
            else
            {
                sb.AppendFormat(
                    ']\r\n{0}\r\n',
                    x.Expression);
            }

            Console.WriteLine(sb);

            if (o.dumpScope && state.hasHashChanged())
            {
                Console.WriteLine(hl(state.serialize(state.scope)));
            }
        }
    }
});

@{
    runtime = {
        '$internal': {
            initTrace: @(aphid) {
                var s = new AphidSerializer(aphid);
                s.IgnoreFunctions = true;
                s.IgnoreSpecialVariables = true;
                s.SplitStrings = true;
                s.StringChunkSize = 90;
                s.MaxElements = -1;                

                ret {
                    aphid,
                    serialize: s.Serialize,
                    out: new StringBuilder(),
                    getPos: TokenHelper.GetIndexPosition,
                    readScript: AphidScript.Read,
                    highlight: SyntaxHighlightingFormatter.Format,
                    scope: aphid.InitialScope,
                    lastScopeHash: null,
                    hasHashChanged: @{
                        if ((var h = scope.GetDeepHashCode()) != lastScopeHash) {
                            lastScopeHash = h;
                            ret true;
                        } else {
                            ret false;
                        }
                    },
                    posMemoizer: new ArgLockingMemoizer[Tuple[string, int], Tuple[int, int]](),
                }
            },            
        },
        trace: {
            options: {
                showFilename: true,
                showOffset: true,
                calculatePosition: true,
                syntaxHighlighting: true,
                dumpScope: true,
                typeFilter: null,
                predicate: null,
            },
            expressions: _trace(OnInterpretExpression),
            statements: _trace(OnInterpretStatement),
        },
    }
}();

