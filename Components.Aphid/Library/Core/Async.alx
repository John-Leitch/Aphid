var async;
var when;
var wait;

@{
    using System.Threading.Tasks;
    _p = macro(@(n){ Parallel.n });
    _pf = macro(@{ _p(For) });
    _pe = macro(@{ _p(ForEach) });
    _f = macro(@(s, b) { opts == null ? _pe()(s, b) : _pe()(s, opts, b) });
    _r = macro(@(f, t, b) { opts == null ? _pf()(f, t, b) : _pf()(f, t, opts, b) });

    _select = macro(@(p) {
        @(predicate, source) {
            var result = [];
            _f(
                source,
                @{
                    var x = predicate($_);
                    lock result p;
                });

            ret result
        }
    });

    _thread = macro(@(_i){
        @(action, state) {
            var t = new Thread(action);
            _i;
            
            if (state defined) {
                t.Start(state);
            } else {
                t.Start();
            }

            ret t;
        }
    });

    async = {
        opts: null,
        degree: @(degrees) opts = new ParallelOptions() @() { $_.MaxDegreeOfParallelism = degrees; ret $_ },
        select: _select(result.add(x)),        
        selectMany: _select(x->result.add),
        forEach: @(body, source) {
            _f(source, body);

            ret source;
        },        
        range: @(from, to, body) { _r(from, to, body) },
        to: @(to, body) { _r(0, to, body) },
        map: select,
        many: selectMany,
        reduce: selectMany,
        each: forEach,
        iter: forEach,
        run: @(action) Task.Factory.StartNew(action),
        task: run,
        action: run,
        long: @(action) Task.Factory.StartNew(action, TaskCreationOptions.LongRunning),
        delay: Task.Delay,
        pool: ThreadPool.QueueUserWorkItem,
        sleep: Thread.Sleep,
        thread: _thread(),
        background: _thread(t.IsBackground = true),
    };

    when = { all: Task.WhenAll, any: Task.WhenAny, };
    wait = { all: Task.WaitAll, any: Task.WaitAny, };
}();