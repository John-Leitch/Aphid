var cdb;

@{
    #'System/Stdio';
    #'Meta/Code/TokenMinimizer';

    cdb = {
        cdbPath: 'c:\\debuggers\\cdb.exe',
        cdbProc: null,
        stdIn: null,
        redirectTask: null,
        consoleOut: true,    
        serializer: null,
        quote: null,
        buffers: { shared: null, stdOut: null, stdError: null },
        callbacks: {} |< @(o) buffers.Keys->@()o[$_] = null,
        open: @(dmpFile) run('-Z "{0}"' :: dmpFile),
        run: @(args) {
            var s = new AphidSerializer(aphid);
            s.AlwaysQuoteKeys = true;
            s.UseDoubleQuotes = true;
            s.IgnoreLazyLists = false;
            s.IgnoreFunctions = true;
            s.IgnoreSpecialVariables = true;
            s.MaxElements = -1;
            s.SafeCollectionAccess = true;
            s.StringReferenceThreshold = 100000;
            s.SplitStrings = false;
            serializer = s;
            quote = serializer.Serialize;

            var si = new ProcessStartInfo(cdbPath, args);
            si.UseShellExecute = false;
            si.RedirectStandardError = true;
            si.RedirectStandardInput = true;
            si.RedirectStandardOutput = true;
            si.CreateNoWindow = true;
            si.WindowStyle = ProcessWindowStyle.Hidden;
            cdbProc = Process.Start(si);
            stdIn = cdbProc.StandardInput;
            buffers | keys->@() buffers[$_] = new StringBuilder();        

            redirectTask = async.long(@()
                stdio.redirect(
                    cdbProc,
                    @(data, isError){
                        _append = macro(@(n) { 
                            buffers.n.Append(data);

                            if (callbacks.n != null) {
                                callbacks.n(data, isError);
                            }
                        });

                        _append(shared);

                        if (!isError) {
                            _append(stdOut);
                        } else {
                            _append(stdErr);
                        }
                        
                        if (consoleOut) {
                            Console.Write(data);
                        }
                    }));
        },
        writeLineCore: @(input) {
            // printInfo('~Cyan~[WriteLine]~R~ {0}', input);
            stdIn.WriteLine(input);
        },
        write: @(input, flush) {
            $(var t = input.GetType())
                string: writeLineCore(input),
                AphidObject: input | quote | writeLineCore,
                IEnumerable.IsAssignableFrom(t) ?
                    input->@() write($_, false) :
                    ex.arg(input);
            
            if (!(flush defined) || flush) {
                stdIn.Flush();
            }        
        },
        
        template: {
            cmdOutXml: @{
                load System.Xml.Linq;
                using System.Xml.Linq;
                var indent = 0;
                var margin = @() '  ' * indent;
                var w = Console.WriteLine;
                var padding = '\r\n' * 3;
                padding | w;
                using System.Collections.Generic;
                var lines = new List[Object]();
                new XDeclaration("1.0", "utf-8", "yes") |> w;
                new XAttribute('Cmd', cmdIn) @w('<CmdOut {0}>');

                var line = null;
                indent++;
                while ((line = Console.In.ReadLine()) != null) {
                    new XElement('CmdLineOut', line)
                    @w('{0}{1}', margin());
                }
                indent--;
                w('</CmdOut>');
                padding | w;
            },

            cmdOutAphidObject: @{
                using System.Collections.Generic;
                var w = Console.WriteLine;
                var padding = '\r\n' * 3;
                padding | w;               
                
                var lines = new List[Object]();
                var line = null;
                
                while ((line = Console.In.ReadLine()) != null) {
                    if (line.TrimEnd() != '') {
                        line | lines.Add;
                    }
                }

                lines | this.'$aphid'.Serializer.Serialize | w;
                padding | w;
            },

            format: @(tmplFunc)
                tmplFunc[0].Context.Code.Substring(
                    (var startOff = tmplFunc.Body^!@.Index),
                    (tmplFunc.Body$! @() $_.Index + $_.Length) - startOff)
                | minTokens
                | quote,
        },    
        execBlock: @(dbgCmd, aphidBlock)
            strOut(@{%>
                .shell -ci <%= dbgCmd | quote %> aphid64 * #'std';var cmdIn=<%= dbgCmd | quote %>;eval(<%= aphidBlock | template.format %>)
            <%})
            .ToString()
            .Trim(),
        pipe: @(dbgCmd) execBlock(dbgCmd, cdb.template.cmdOutAphidObject) | write,
        sos: {
            findModules: @()
                '%windir%'
                | env.expand
                @io.end('Microsoft.NET')
                @io.find.files('sos.dll'),

            loadExtension: @()
                findModules()
                ->@format('!load {0}')
                |> write,
        },
    }
}();