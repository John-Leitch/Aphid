_c = macro(@(n, f) { _c2(n, '', '', f)  });
_c2 = macro(@(n, pref1, pref2, type) { _cInner(id(pref1, n), id(To, pref2, type)) });
_cInner = macro(@(n, f) { extend unknown { n: @(x) Convert.f(x) } });

_cu = macro(@(n, f3) {
    _c(n, f3);
    _c2(n, u, U, f3);    
});

_c(byte, Byte);
_c(sbyte, SByte);
_cu(short, Int16);
_cu(int, Int32);
_cu(long, Int64);
_cu(long, Int64);
_c(float, Single);
_c(double, Double);

extend unknown { char: @(x) Convert.ToChar(Convert.ToByte(x)), }

using System.Collections;
_h = macro(@(s) { _f(s, $_) });
_i = macro(@(s, a) { _f(s, $_.a()) });
_f = macro(@(s, a) { format('{0:x' + quote(s) + '}', a) });
_e = macro(@(t, v) { throw new ArgumentException('Cannot convert ' + quote(t) + ' ' + v + ' to hex') });

var hex = @() ($(var t = $_.GetType())
    bool: $_ ? '01' : '00',
    sbyte, byte: _h(2),
    short, ushort: _h(4),
    int, uint: _h(8),
    long, ulong: _h(16),    
    char: _i(4, ushort),
    string: ($_ -> (@() _i(4, ushort)) |> concat),
    float: _i(8, uint),
    double: _i(16, ulong),
    decimal: (var u = $_.ulong()) == $_ ? _f(16, u) : _e(decimal, $_),
    t.GetInterface(IEnumerable) != null ? ($_->hex |> concat) : _e(type, $_.GetType()));

var unhex = @()
    '-,: \t\r\n'
    | $_.Split
    -<(@() ($($_.Length % 2) 0: $_, $_.PadLeft($_.Length + 1, '0')).ToCharArray() @every(2))
    ->concat
    ->@() Convert.ToByte($_, 16);
    
//aphidupdatescripts.cmd & aphid64 * #'std'; this.dir('\\$ext\\.unknown'); ['uint', 'ulong', 'long']-^>@()0xdeadbeef.{$_}() @()print('{0} 0x{0:x8} {1}', $_, $_.GetType().Name)