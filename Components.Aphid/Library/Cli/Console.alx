// #'conversion';
using Components;
using Components.ConsolePlus;
using Components.External.ConsolePlus;

var cls;
var exit = @() ($args.Count != 0 ? $_ : 0) |> Environment.Exit;
var getCommand = @() Environment.CommandLine;
var getCommandLineArgs = Environment.GetCommandLineArgs;

var fixColors = @{
    Console.ForegroundColor = ConsoleColor.Gray;
    Console.BackgroundColor = ConsoleColor.Black;
};

var console;
var head = @(msg){ Cli.WriteHeader($_, console.defaultHeaderStyle) };
var header = head;
var subhead = @(msg) { Cli.WriteSubheader(msg, console.defaultSubheaderStyle) };
var subheader = subhead;

var fatal = @{
    var msg = 'Fatal error';
    throw $($args.Count) 0: msg, '{0}: {1}' :: [ msg, $args[0] :: ($args @aq.skip(1)) ];
};

_ci = macro(@(a) { if (exists()) { a } });
_bp = macro(@{ Console.SetCursorPosition(0, state.startPos + barYOffset) });

@{
    using Components.Aphid.UI.Formatters;
    
    using Components.PInvoke;
    using Components.ConsolePlus;

    console = {
        vt100Supported: VT100.TryEnable(),
        writeLine: Console.WriteLine,
        line: writeLine,        
        write: Console.Write,
        head,
        header,
        subhead,
        subheader,
        defaultHeaderStyle: '~|Blue~~White~',
        defaultSubheaderStyle: defaultHeaderStyle,
    
        free: @{            
            Cli.UseTrace = true;
            Kernel32.FreeConsole();
        },

        getWindow: Kernel32.GetConsoleWindow,
        exists: getWindow @> @!= IntPtr.Zero,
        runWindowCmd: @User32.ShowWindow(getWindow()),
        show: @() runWindowCmd(ShowWindowCommands.SW_SHOW),
        hide: @() runWindowCmd(ShowWindowCommands.SW_HIDE),
        highlight: SyntaxHighlightingFormatter.Format,
        writeCode: highlight @> line,
        code: writeCode,

        bindKeyAsync: @(key, action) {
            using System.Threading;

            var t = new Thread(@{
                while (true) {
                    action();

                    while (Console.ReadKey(true).Key != key) {
                    }
                }
            });

            t.IsBackground = true;
            t.Start();

            ret t;
        },

        clear: @() _ci(Console.Clear()),

        setTitle: @(title) _ci(Console.Title = title),

        progress: {
            create: @(total) {
                var p = {
                    state: {
                        startPos: null,
                        msg: '',
                        progress: null,
                    },
                    
                    barYOffset: 1,
                    msgYOffset: 4,

                    init: @(total){    
                        state.startPos = Console.CursorTop;

                        if (Console.CursorTop >= Console.BufferHeight + msgYOffset + 2) {
                            Console.BufferHeight = Console.CursorTop + msgYOffset + 2;
                        }

                        state.progress = new CliProgressBar(total);
                    },

                    writeBar: @{
                        _bp();
                        state.progress.Write();
                    },

                    writeMsg: @{
                        var maxWidth = Console.WindowWidth - 2;

                        if (state.msg.Length > maxWidth) {
                            state.msg = state.msg.Remove(maxWidth - 3) + '...';
                        }

                        Console.SetCursorPosition(
                            Console.WindowWidth / 2 - state.msg.Length / 2 |> Math.Floor,
                            state.startPos + msgYOffset - barYOffset);
                        
                        Console.Write(state.msg);
                        Console.SetCursorPosition(0, state.startPos);
                    },

                    inc: @{
                        _bp();
                        state.progress.IncrementAndWrite();
                    },

                    update: @{
                        if ($args.Count > 0) {
                            lock state {
                                setValue($_);
                                $args.RemoveAt(0);
                                apply(setStatus, $args);
                            }
                        }
                    },

                    setValue: @(value) {
                        state.progress.Value = value.double();
                        writeBar();
                    },

                    setStatus: @{
                        var lastLen = state.msg.Length;                
                        
                        switch ($args.Count) {
                            0: state.msg = '';
                            1: state.msg = $_;
                            default: {
                                var fmt = $_;
                                $args.RemoveAt(0);
                                state.msg = format(fmt, $args);
                            }
                        }

                        if (state.msg.Length < lastLen) {
                            Console.SetCursorPosition(
                                0,
                                state.startPos + msgYOffset - barYOffset);

                            Console.Write(new string(' ', Console.WindowWidth));
                        }

                        writeMsg();
                    },

                    finish: @{
                        Console.SetCursorPosition(0, state.startPos + msgYOffset + 1);
                    }
                };

                p.init(total);
                p.writeBar();
                ret p;
            },
        },
        pipeline: {            
            processCore: @(isAsync, func, source) {
                Console.CursorVisible = false;

                try {
                    var curRef = [0.int()] @seq.array(Object);
                    var total = source #!;
                    var result = [];
                    var p = console.progress.create(total.double());
                    
                    var next = @{
                        var cur = Interlocked.Increment.Members[0].Invoke(
                            null,
                            curRef);

                        if (udpateReset.WaitOne(0)) {
                            p.update(
                                cur, 
                                '{0:n0}/{1:n0} ({2:p2})' :: [
                                    cur.int(),
                                    total.int(),
                                    (total != 0 ? (cur / total) : 0).double()
                                ]);
                        }
                    };

                    p.setStatus('Starting task');
                    var udpateReset = new AutoResetEvent(true);
                    // using (var udpateReset = new AutoResetEvent(false)) {
                        async.background(@{
                            while (curRef[0] < total) {
                                async.sleep(10);
                                udpateReset.Set();
                            }
                        });

                        if (!isAsync) {
                            source for {
                                next();
                                result.add(func($_));
                            };
                        } else {
                            result = source @async.select(@{
                                next();
                                ret func($_);                                
                            });
                        }

                        next();
                    // }
                    
                    p.finish();
                    
                    ret result;
                } finally {
                    Console.CursorVisible = true;
                }
            },
            process: @(func, source) processCore(false, func, source),
            parallel: @(func, source) processCore(true, func, source),
        },

        getHistory: @(filterSyntaxErrors) this.'$replConsole'
            .GetType().BaseType
            .GetField('_history', BindingFlags.NonPublic | BindingFlags.Instance)
            .GetValue(this.'$replConsole')
            | reverse
            -?<!(@() filterSyntaxErrors defined && filterSyntaxErrors ? 
                $_ | parse != null :
                true)
            ->(@()$_ + 
                ($_
                |>?> parse
                |>?> last
                @() ($_ != null && $_.IsStatement() ? '' : ';'))),

        dumpHistory: @(filterSyntaxErrors)
            filterSyntaxErrors defined ? filterSyntaxErrors : false
            |> getHistory
            -> code,

        color: {
            invert = @(c) c->(@(b) (0xff - b).byte()) |> toArray,            
            invertText = @(t) {
                _inv = macro(@(n) { t.n = (t.n == null ? [0,0,0] : t.n) | invert });
                _inv(ForegroundRgb);
                _inv(BackgroundRgb);
                ret t
            },
            remove: @(t) t ~: '\\x1b.*?m',
            clearResets: @(t) t.Replace(VT100.Reset, ''),
            strLen: @(s) s | remove @.Length,
        },

        dumpSysColors: @{
            SystemColor
                .GetFields()
                ->@(f)$_
                    .GetValue(null)
                    @(c) c | VT100.Background
                    @format(
                        '{3}{0}{1}{2}',
                        VT100.Foreground(c|color.invert),
                        f.Name.PadRight(Console.BufferWidth - 2), VT100.Reset)
                        |> line;
        },

        stdIn: {
            lines: @(handle){
                var lines = new List[string]();

                if (handle defined) {
                    while ((line = Console.In.ReadLine()) != null) {
                        line | handle | lines.Add;
                    }
                } else {
                    while ((line = Console.In.ReadLine()) != null) {
                        line | lines.Add;
                    }   
                }

                ret lines;
            },

            text: @() Console.In.ReadToEnd(),
            txt: text,
        },
    };

    cls = console.clear;
}();

