var getCommand = @() Environment.CommandLine;
var getCommandLineArgs = @() Environment.GetCommandLineArgs();

var fixColors = @{
    Console.ForegroundColor = ConsoleColor.Gray;
    Console.BackgroundColor = ConsoleColor.Black;
};

var console;
var head = @(msg){ Cli.WriteHeader($_, console.defaultHeaderStyle) };
var header = head;
var subhead = @(msg) { Cli.WriteSubheader(msg, console.defaultSubheaderStyle) };
var subheader = subhead;

_ci = macro(@(a) { if (exists()) { a } });
_bp = macro(@{ Console.SetCursorPosition(0, state.startPos + barYOffset) });

@{
    using Components.Aphid.UI.Formatters;
    
    using Components.PInvoke;
    using Components.ConsolePlus;

    console = {
        head,
        header,
        subhead,
        subheader,
        defaultHeaderStyle: '~|Blue~~White~',
        defaultSubheaderStyle: defaultHeaderStyle,
    
        free: @{            
            Cli.UseTrace = true;
            Kernel32.FreeConsole();
        },

        getWindow: Kernel32.GetConsoleWindow,
        exists: getWindow @> @!= IntPtr.Zero,
        runWindowCmd: @User32.ShowWindow(getWindow()),
        show: @() runWindowCmd(ShowWindowCommands.SW_SHOW),
        hide: @() runWindowCmd(ShowWindowCommands.SW_HIDE),
        highlight: SyntaxHighlightingFormatter.Format,
        writeCode: highlight @> Console.WriteLine,

        bindKeyAsync: @(key, action) {
            using System.Threading;

            var t = new Thread(@{
                while (true) {
                    action();

                    while (Console.ReadKey(true).Key != key) {
                    }
                }
            });

            t.IsBackground = true;
            t.Start();

            ret t;
        },

        clear: @() _ci(Console.Clear()),

        setTitle: @(title) _ci(Console.Title = title),

        progress: {
            create: @(total) {
                var p = {
                    state: {
                        startPos: null,
                        msg: '',
                        progress: null,
                    },
                    
                    barYOffset: 1,
                    msgYOffset: 4,

                    init: @(total){    
                        state.startPos = Console.CursorTop;

                        if (Console.CursorTop >= Console.BufferHeight + msgYOffset + 2) {
                            Console.BufferHeight = Console.CursorTop + msgYOffset + 2;
                        }

                        state.progress = new CliProgressBar(total);
                    },

                    writeBar: @{
                        _bp();
                        state.progress.Write();
                    },

                    writeMsg: @{
                        var maxWidth = Console.WindowWidth - 2;

                        if (state.msg.Length > maxWidth) {
                            state.msg = state.msg.Remove(maxWidth - 3) + '...';
                        }

                        Console.SetCursorPosition(
                            Console.WindowWidth / 2 - state.msg.Length / 2 |> Math.Floor,
                            state.startPos + msgYOffset - barYOffset);
                        
                        Console.Write(state.msg);
                        Console.SetCursorPosition(0, state.startPos);
                    },

                    inc: @{
                        _bp();
                        state.progress.IncrementAndWrite();
                    },

                    update: @{
                        if ($args.Count > 0) {
                            lock state {
                                setValue($_);
                                $args.RemoveAt(0);
                                apply(setStatus, $args);
                            }
                        }
                    },

                    setValue: @(value) {
                        state.progress.Value = value.double();
                        writeBar();
                    },

                    setStatus: @{
                        var lastLen = state.msg.Length;                
                        
                        switch ($args.Count) {
                            0: state.msg = '';
                            1: state.msg = $_;
                            default: {
                                var fmt = $_;
                                $args.RemoveAt(0);
                                state.msg = format(fmt, $args);
                            }
                        }

                        if (state.msg.Length < lastLen) {
                            Console.SetCursorPosition(
                                0,
                                state.startPos + msgYOffset - barYOffset);

                            Console.Write(new string(' ', Console.WindowWidth));
                        }

                        writeMsg();
                    },

                    finish: @{
                        Console.SetCursorPosition(0, state.startPos + msgYOffset + 1);
                    }
                };

                p.init(total);
                p.writeBar();
                ret p;
            },
        },
        pipeline: {            
            processCore: @(isAsync, func, source) {
                Console.CursorVisible = false;

                try {
                    var curRef = [0.int()] @seq.array(Object);
                    var total = source #!;
                    var result = [];
                    var p = console.progress.create(total.double());
                    
                    var next = @{
                        var cur = Interlocked.Increment.Members[0].Invoke(
                            null,
                            curRef);

                        if (udpateReset.WaitOne(0)) {
                            p.update(
                                cur, 
                                '{0:n0}/{1:n0} ({2:p2})' :: [
                                    cur.int(),
                                    total.int(),
                                    (total != 0 ? (cur / total) : 0).double()
                                ]);
                        }
                    };

                    p.setStatus('Starting task');
                    var udpateReset = new AutoResetEvent(true);
                    // using (var udpateReset = new AutoResetEvent(false)) {
                        async.background(@{
                            while (curRef[0] < total) {
                                async.sleep(10);
                                udpateReset.Set();
                            }
                        });

                        if (!isAsync) {
                            source for {
                                next();
                                result.add(func($_));
                            };
                        } else {
                            result = source @async.select(@{
                                next();
                                ret func($_);                                
                            });
                        }

                        next();
                    // }
                    
                    p.finish();
                    
                    ret result;
                } finally {
                    Console.CursorVisible = true;
                }
            },
            process: @(func, source) processCore(false, func, source),
            parallel: @(func, source) processCore(true, func, source),
        },
    };
}();

var cls = console.clear;

var exit = @() ($args.Count != 0 ? $_ : 0) |> Environment.Exit;

var fatal = @{
    var msg = 'Fatal error';
    throw $($args.Count) 0: msg, '{0}: {1}' :: [ msg, $args[0] :: ($args @aq.skip(1)) ];
};