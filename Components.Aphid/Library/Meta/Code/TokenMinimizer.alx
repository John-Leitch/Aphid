#'Std';
VT100.Enable();

var remoteBlock = @{
    #'Std';
    var indent = 0;
    var margin = @() '  ' * indent;
    print('<?xml version="1.0" encoding="UTF-8" standalone="no" ?>');
    print('<CmdOut>');

    var line = null;
    while ((line = Console.In.ReadLine()) != null) {
        print('{0}<{1}>{2}</{1}>', margin(), 'CmdLineOut', line);
    }

    print('</CmdOut>');
};

//var startOff = remoteBlock.Body^!@.Index;
//var endOff = remoteBlock.Body$! @() $_.Index + $_.Length;
//var len = endOff - startOff;
//var remoteCode = remoteBlock[0].Context.Code.Substring(remoteBlock.Body^!@.Index, len);

var minTokens = @(code, unsafePairs)
    code
    | tokenize
    @(t) t
        @skip(1)
        @every(2)
        @combine(t @every(2) toArray)
        -? (@()($_#!)==2)
        -\(@()$_^!@.Index)
        ->(@(t2)({
            lhs:t2[0],
            rhs:t2[1],
            types: [lhs.TokenType, rhs.TokenType],
            delim: unsafePairs defined && (unsafePairs=?@seqEqual(types)) ? ' ' : '',
            joined: lhs.Lexeme + delim + rhs.Lexeme,
            result: joined | tokenize,
            compare: @(x, y)
                (result#!) == 2 &&
                x.Lexeme == result[y].Lexeme &&
                x.TokenType == result[y].TokenType,
            unsafe: !compare(lhs, 0) || !compare(rhs, 1),
            msg: @() { dump(this); print('Check done for {0}', lhs.Index.int()); ret null; }(),
        }))
        @(p) (p =?@.unsafe)  ? 
            (p-?@.unsafe->@.types)
            @(p2) (unsafePairs defined ? p2 @concat(unsafePairs) : p2)
            @minTokens(code) :
                //p
            (p->(@(x) x.lhs.Lexeme + x.delim) |> concat) + (p$! @(r) r.rhs.Lexeme);
    
remoteCode | minTokens | SyntaxHighlightingFormatter.Format | Console.WriteLine;