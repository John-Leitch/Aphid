// ##'Components.Aphid.Library.IOLibrary';
using System.IO;
using System.Linq;
// var getFsos = @(f, dir, opt) {
//     var filter = '*';
//     var recurse = false;

//     if (opt defined) {
//         if (opt.filter defined) filter = opt.filter;
//         if (opt.recurse defined) recurse = opt.recurse;
//     }

//     ret f(dir, filter, recurse);
// };

// io.dir.getFiles = @getFsos(io.dir.getFilesInternal);
// io.dir.getDirs = @getFsos(io.dir.getDirsInternal);

@ \ (lhs, rhs) lhs @io.end(rhs);
@ .\ (path) path | io.full;

_d = macro(@(f) { Directory.f });
_f = macro(@(f) { File.f });
_p = macro(@(f) { Path.f });
_c = macro(@{ _p(Combine)(lhs, rhs) });
_h = macro(@(f) { pathHelper.f });
_ob = macro(@(o) { _d(EnumerateFiles)(path, pattern defined ? pattern : '*', SearchOption.o) });
@ .* (path, pattern) _ob(TopDirectoryOnly);
@ :* (path, pattern) _ob(AllDirectories);
_ea = macro(@(n, d, p) { _d(id(Enumerate, n))(d, p, SearchOption.AllDirectories) });
_af = macro(@(d, p) { _ea(Files, d, p) });
_ad = macro(@(d, p) { _ea(Directories, d, p) });

_f2 = macro(@(o) {
    @(path, output) output defined ?
        _f(id(WriteAll, o))(path, output) :
        _f(id(ReadAll, o))(path)
});

var io = {
    // pathHelper: Type.GetType('Components.External.PathHelper'),
    dir: _d(Exists),
    file: _f(Exists),

    cd: @(path) path defined ? _d(SetCurrentDirectory)(path) : _d(GetCurrentDirectory)(),

    files: _d(EnumerateFiles),
    dirs: _d(EnumerateDirectories),

    all: {
        files: @() ($($args.Count)
            0: _af('.', '*'),
            1: _af($_, '*'),
            2: _af($_, $args[1]),
            throw new ArgumentException('io.all.files() expects one to three arguments')),
        dirs: @() ($($args.Count)
            0: _ad('.', '*'),
            1: _ad($_, '*'),
            2: _ad($_, $args[1]),
            throw new ArgumentException('io.all.dirs() expects one to three arguments')),
    },

    find: {
        files: @(pattern, path)
            ($($args.Count)
                0: _af('.', '*'),
                1: _af('.', $_),
                2: _af($args[1], $_),
                throw new ArgumentException('io.find.files() expects one to three arguments')),
        dirs: @(pattern, path)
            ($($args.Count)
                0: _ad('.', '*'),
                1: _ad('.', $_),
                2: _ad($args[1], $_),
                throw new ArgumentException('io.find.dirs() expects one to three arguments')),
        file: @(pattern, path)
            ($($args.Count)
                0: _af('.', '*'),
                1: _af('.', $_),
                2: _af($args[1], $_),
                throw new ArgumentException('io.find.files() expects one to three arguments'))
                |> Enumerable.Single,
        dir: @(pattern, path)
            ($($args.Count)
                0: _ad('.', '*'),
                1: _ad('.', $_),
                2: _ad($args[1], $_),
                throw new ArgumentException('io.find.dirs() expects one to three arguments'))
                |> Enumerable.Single,
    },

    first: {
        file: @(pattern, path)
            ($($args.Count)
                0: _af('.', '*'),
                1: _af('.', $_),
                2: _af($args[1], $_),
                throw new ArgumentException('io.find.file() expects zero to two arguments'))
                |> Enumerable.FirstOrDefault,

        dir: @(pattern, path)
            ($($args.Count)
                0: _ad('.', '*'),
                1: _ad('.', $_),
                2: _ad($args[1], $_),
                throw new ArgumentException('io.find.dir() expects zero to two arguments'))
                |> Enumerable.FirstOrDefault,
    },
    
    bytes: _f2(Bytes),
    lines: _f2(Lines),
    text: _f2(Text),
    txt: text,

    out: {
        bytes: _f(WriteAllBytes),
        lines: _f(WriteAllLines),
        text: _f(WriteAllText),
        txt: text,
        append: {
            
            text: _f(AppendAllText),
            txt: text,
            line: @(line, file) text(line + '\r\n', file),
            lines: _f(AppendAllLines), 
        },
    },

    add: out.append,

    del: _f(Delete),
    rd: _d(Delete),
    len: @() (new FileInfo($_)).Length,
    size: len,

    parent: _p(GetDirectoryName),
    up: parent,
    name: _p(GetFileName),
    base: _p(GetFileNameWithoutExtension),
    full: _p(GetFullPath),
    attrs: _f(GetAttributes),

    ext: @(pathOrExt, newExt)
        pathOrExt defined ?
            newExt defined ?
                _p(ChangeExtension(pathOrExt, newExt)) :
                _p(GetExtension(pathOrExt)) :
            throw new ArgumentException('Function io.ext() expects one or two arguments'),

    tmp: _p(GetTempPath),
    rnd: _p(GetTempFileName),
    copy: _f(Copy),
    cp: copy,
    move: _f(Move),
    mov: move,
    mv: move,

    created: _f(GetCreationTime),
    date: created,

    accessed: _f(GetLastAccessTime),
    last: accessed,

    modified: _f(GetLastWriteTime),
    touched: modified,

    drives: _d(GetLogicalDrives),

    append: @(rhs, lhs) _c(),
    suffix: append,
    tail: append,
    end: append,

    pre: @(lhs, rhs) _c(),
    prefix: pre,
    prepend: pre,
    head: pre,
    start: pre,

    concat: _p(Combine),
    join: concat,
    
    local: @(f) new Uri(f) @.IsFile,
    remote: @(f) !local(f),

    open: {
        create: _f(Create),
        read: _f(OpenRead),
        write: _f(OpenWrite),
        share: @(path) _f(Open)(
            path,
            FileMode.OpenOrCreate,
            FileAccess.ReadWrite,
            FileShare.ReadWrite),
        
        append: _f(AppendText),
    },

    // entry: @() $args.Count == 0 ? _h(GetEntryDirectory)() : _h(GetEntryPath)($args),
    // executing: @() $args.Count == 0 ? _h(GetExecutingDirectory)() : _h(GetExecutingyPath)($args),
};

var isDir = io.dir;
var isFile = io.file;
var dirExists = io.dir;
var fileExists = io.file;