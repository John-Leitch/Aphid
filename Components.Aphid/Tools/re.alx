#'Std';
// #'re.db';

this @mix(console);

{
    string path: '-p',
    string filter: '-f',
    string excludePattern: '-x',
    bool replace: '-r',    
    bool useEvaluator: '-e',
    bool dumpOut: '-d',
    bool recurse: '-s',
    string out: '-o',
    bool write: '-w',
    int indentSize: '-i',
    int excerptLines: '-l',
    int threads: '-t',
    bool uniqueFiles: '-1',
    int verbosity: '-v',
    bool disableCaptures: '-c-',
}
| importArgs;

var normalizeLines = true;

_da = macro(@(n, v) { if (n == null) { n = v } });
_da(filter, '*');
_da(excludePattern, null);
_da(path, '.');
_da(indentSize, 2);
_da(excerptLines, 3);
_da(verbosity, 2);
_da(dumpOut, false);

var toPrintable = @(text, ignoreLines) $_  ~: [
    ignoreLines defined && ignoreLines ?
        '[\\x00-\\x09\\x0b-\\x0c\\x0e-\\x1f\\x7f-\xff]' :
        '[\\x00-\\x1f\\x7f-\xff]',
    '.'
];

var groupIndent = ' ' * indentSize;
var reOptions = RegexOptions.IgnoreCase | RegexOptions.Compiled;
var context = {};

if (!anyRemaining) {
    SystemColor.DodgerBlue.CopyTo(SystemColor.CadetBlue, 0);
    var hdr = 'Lycomorpha {0}' :: AphidExpression.Assembly.GetName().Version;
    var y;

    if (Environment.UserInteractive) {
        cls();
        y = Console.CursorTop;
    }

    color.header(hdr);    
    print(
        aphid.InitialScope.'$block'
        >$ast.is.text
        |> highlight
        @()$_
            .Split('\n')
            ->(@()$_.Trim().Contains('$R$')?
                $_~:'\\$R\\$'|>color.remove:
                $_)
            @join('\n'));

    if (Environment.UserInteractive) {
        color.glitch.header(hdr, y);
    }

    exit(1);
}

var func = recurse ? io.all.files : io.files;
var execEvaluator;

if (useEvaluator) {
    execEvaluator = 
        Environment.CommandLine
        | ArgLexer.GetTokenInfo
        >^(@(x) x.Value == '-e')
        @.Offset
        @+2
        |> Environment.CommandLine.Substring
        |> parseFunc;
} else {
    execEvaluator = @{};
}

var pattern = remaining[0];
var styleEscape = Cli.StyleEscape;

func(path, filter) for (file) {    
    if (excludePattern != null && Regex.IsMatch(file, excludePattern, reOptions)) {
        if (verbosity >= 4) {
            info('Skipping ~Yellow~{0}~R~ due to exclude pattern', file | styleEscape);
        }
        continue;
    }

    if (verbosity >= 3) {
        info('Searching {0}', file | styleEscape);
    }

    var text;

    try {
        file = file | io.full;
        text = file | io.txt;

        // if (normalizeLines) {
        //     text = text.Replace('\r\n', '\n').Replace('\r', '\n').Replace('\n', '\r\n');
        // }

        // text = toPrintable(text, true);
    } catch (e) {
        fail('Could not read file: {0}', e.message | styleEscape);
        continue;
    }

    var matches = Regex.Matches(text, pattern, reOptions);
    var c = matches#!;

    if (c == 0) {
        continue;
    }
    
    var excerptColor = color.pair(
        SystemColor.Cornsilk | color.darken,
        SystemColor.DarkSlateGray | color.darken);
    
    var highlightColor =color.pair(
        SystemColor.Highlight,
        SystemColor.Highlight | color.invert);

    '{0} {1} in {2}' :: [
        c,
        'Match' |> c != 1 ? language.pluralize : @(x)x,
        file | styleEscape
    ]
    |> color.header;
    line();

    // ('A' * (Console.BufferWidth + 0 - 5)) + 'foo' | colorHeader;
    // @{%>c:\AAAA\AAAA\AAAA\AAAA\AAAA\AAAA\AAAA\AAAA\AAAA\AAAA\source\Aphid\Components.Aphid\bin\Release64\Library\Meta\Code\Generation\StringEmitter.alx<%}[1].Text @format('{0} {0}') |> colorHeader;
    
    // line();
    // ('Foo1AAAA AAAA AAAA AAAA AAAA 
    // AAAA AAAA AAAA AAAA AAAA AAAA 
    // BBBBBBBBB 
    // AAAA AAAA AAAA AAAA AAAA
    //  AAAA AAAA AAAA AAAA AAAA '~:'\\s') * 4 |> colorHeader;
// null | dumpe;
    var matchNum = 0;
    var replacements = new List[AphidObject]();
    var updatedOffset = 0;
    var displayText = null;

    matches for (m) {        
        var i2 = 0;
        matchNum++;
        m.Groups for (g) {
            if (i2 > 0) {                
                if (disableCaptures) {
                    continue;
                } else if ($_.Length == 0) {
                    '{0}Capture Group {1}: empty' :: [ groupIndent, i2++ ]
                    |> code;

                    if (i2 == (m.Groups#!)) {
                        line();
                    }
                    continue;
                }
            }

            if (displayText == null) {
                displayText = toPrintable(text, true);
            }

            var pos = TokenHelper.GetIndexPosition(displayText, g.Index);
            _pi = macro(@(n) { (pos != null ? pos.n + 1 : 'Error calculating position') });
            var newLen;
            line('{0}\r\n{1}', 
                ($(i2) 0: 'Match {0}', '{1}Capture Group {2}') +
                ': Line {3:n0}, Column {4:n0}, Index {5:n0}, Length {6:n0}' :: [
                    matchNum,
                    groupIndent,
                    i2,
                    _pi(Item1),
                    _pi(Item2),
                    g.Index,
                    g.Length
                ]
                |> highlight                
                |> (@()format(
                    i2 == 0  ? '{0}{1}{0}{2}{3}' : '{1}',
                    SystemColor.DarkBlue | VT100.Background,
                    $_,
                    new string(' ', Math.Max(0, Console.BufferWidth - 1 - ($_ | color.strLen))),
                    VT100.Reset)),
                i2++ == 0 ?
                    TokenHelper
                        .GetCodeExcerpt(
                            displayText.Insert(g.Index + g.Length, excerptColor).Insert(g.Index, highlightColor),
                            g.Index + highlightColor.Length,
                            excerptLines)
                        .TrimEnd()
                        .Split(['\r\n'],  StringSplitOptions.None)
                        ->(@(l) '{0}{1}{0}{2}{3}' :: [
                            excerptColor,
                            l,
                            color.pad(l),
                            VT100.Reset
                        ])
                        @join('\r\n')
                        @+ '\r\n' :
                    '{0}{1}{2}\r\n' :: [ groupIndent, g.Value | toPrintable | highlight, VT100.Reset ]);
        };

        var replacement;
        if (useEvaluator) {
            var f = new AphidFunction(execEvaluator.Args, execEvaluator.Body, this);
            replacement = Regex.Replace($_.Groups[0].Value, pattern, f, reOptions);
        } else if (out != null) {
            replacement = Regex.Replace($_.Groups[0].Value, pattern, out, reOptions);
        }

        if (useEvaluator || out != null) {
            replacements.Add({ offset: updatedOffset + $_.Index, len: replacement.Length });
            updatedOffset += replacement.Length - $_.Length;
        }

        if (out != null || useEvaluator) {
            line('{0}{1}\r\n{0}{2}\r\n',
                groupIndent,
                'Replacement {0}:' :: matchNum |> highlight,
                replacement);
        }
    };
//source\aphid\components.aphid\tools\makeexe -f *.alx -s "#.*?std"; -o '/*nostdheader*/' -dump
    if ((matches#!) > 0 && (dumpOut || write) && (useEvaluator || out != null)) {
        var updated;
        
        if (useEvaluator) {
            var f = new AphidFunction(execEvaluator.Args, execEvaluator.Body, this);
            updated = Regex.Replace(text, pattern, f, reOptions);            
        } else if (out != null) {
            updated = Regex.Replace(text, pattern, out, reOptions);
        }

        if (dumpOut) {
            var tmp = updated;
            replacements | reverse for {
                tmp = tmp
                    .Insert($_.offset + $_.len, excerptColor)
                    .Insert($_.offset, highlightColor);
            };
            tmp.Split(['\r\n'],  StringSplitOptions.None) for line(
                '{0}{1}{0}{2}{3}',
                excerptColor,
                $_ | toPrintable,
                color.pad($_),                            
                VT100.Reset);

            line();

        }

        if (write) {
            printInfo('Writing updated text');
            updated |> @io.txt(file);
        }
    }
};

exit();
%>
re pattern [-p path] [-f filter] [-s] [-l lines] [-d] [-t take] [-1] [-o replacement] [-w] [-n depth] [-m file count] [-a timeout] [-h] [-c] [-i indent size] [-e statements ...] 

[pattern] (Required)
$R$A .NET regular expression (Perl 5 compatible) used to search files.

-p [path] (Optional)
$R$An absolute or relative path to search. If not specified, the current working directory is used.

-f [filter] (Optional)
$R$A wildcard search pattern used to filter files prior to searching. If not specified, * is used.

-s (Optional)
$R$Performs a recursive search that includes all subdirectories and files matched by the filter.

-l [lines] (Optional)
$R$The number of lines above and below the match to include in the preview excerpt. Default is 3.

-d (Optional)
$R$Dump the complete contents of any files matched to std out with matches highlighted. When running in replacement mode, matches are updated with their respective replacement value. This feature can be used to preview replacements without modifying files.

-t [take] (Optional) !Todo
$R$Limit the maximum number of file matches returned to the specified value.

-1 (Optional) !Todo
$R$Track contents of files searched and skip any duplicates encountered.

-o [replacement] (Optional)
$R$A replacement used to update pattern mathes. Uses standard .NET syntax to reference capture groups e.g. $1 for capture group 1. Runs in preview mode, writing replacements to std out without modifying the matched file unless write mode is explicitly enabled with the -w flag.

-w (Optional)
$R$Write replacements to matched files. In general, this option should not be used until the changes have been confirmed by previewing them with the -d option. 

-n [depth] (Optional) !Todo
$R$The maximum depth to search when running in recursive mode.

-m [file count] (Optional) !Todo
$R$The maximum number of files to search.

-a [timeout] (Optional) !Todo
$R$The maximum time in milliseconds a file search is considered alive. If exceeded, the remainder of the file is ignored and the search proceeds to the next file.

-h (Optional) !Todo
$R$Only search non-binary, human readable files.

-c (Optional) !Todo
$R$Suppresses all default output to std out. Intented for completely custom output written by user defined evaluators.

-i [indent size] (Optional)
$R$The number of spaces to indent when writing capture groups to std out. Default is 2.

-e [statements ...] (Optional)
$R$A sequence of Aphid statements executed every time a pattern is matched. The entire Aphid programming language is supported, including seamless .NET interop and all Aphid headers. When running in replacement mode, an updated value for the current pattern match can be provided using a return statement, although a return value is not required. State can be persisted between matches by using the context object, and for more advanced scenarios, the internal state of the tool itself can be accessed and modified.
