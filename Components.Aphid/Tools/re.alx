#'Std';

{
    string path: '-p',
    string filter: '-f',
    bool replace: '-r',    
    bool useEvaluator: '-e',
    bool dumpOut: '-d',
    bool recurse: '-s',
    string out: '-o',
    bool write: '-w',
    int indentSize: '-t',
    int excerptLines: '-l',
}
| console.importArgs;

_da = macro(@(n, v) { if (n == null) { n = v } });
_da(filter, '*');
_da(path, '.');
_da(indentSize, 2);
_da(excerptLines, 3);
_da(dumpOut, false);

var groupIndent = ' ' * indentSize;
var reOptions = RegexOptions.IgnoreCase | RegexOptions.Compiled;
var context = {};
var memoizer = new ArgLockingMemoizer[string, string]();

var funcLocks = new Dictionary[IAphidCallable, Object]();
var funcMemoizerTable = new Dictionary[IAphidCallable, Dictionary[Type, Object]]();

var lookupArgs = new ThreadLocal[Object.MakeArrayType()](@() 
    [ null, null ]
    @seq.array(Object));

var get = @(key, def, dict)
    ($(def.GetType())
        RuntimeType, Type: getOrNew,
        getOrCreate)(key, def, dict);

var getOrNew = @(key, type, dict) getOrCreate(key, @() new type(), dict);

var getOrCreate = @(key, create, dict) {
    var args = lookupArgs.Value;
    args.Set(0, key);
    
    if (!dict.TryGetValue.Members[0].Invoke(dict, args)) {
        dict.Add(key, var result = create());
        ret result;
    } else {
        ret args[1];
    }
};



var cache = @(retType, f){
    var funcLockTable = funcLocks @get(f, LockTable[Type]);
    // lock (funcLockTable

    lock (funcMemoizerTable) {
        if (!funcMemoizerTable.TryGetValue.Members[0].Invoke(funcMemoizerTable, args)) {
            funcMemoizerTable.Add(f, funcMemoizers = new Dictionary[Type, Object]());
        } else {
            funcMemoizers = args[1];
        }
    }

    
    
};

// cache(string, format);

extend AphidFunction {
    cache: @(callable, argType, retType) new ArgLockingMemoizer[argType, retType](),
}

if (!anyRemaining) {
    print(
        're { -p [path] } { -f [filter] } { -r } { -s } { -o [out str] } ' +
        '{ -t [group indent size] } { -d } [pattern] { -e evaluator statements ... }');

    exit(1);
}

var func = recurse ? io.all.files : io.files;
var execEvaluator;

if (useEvaluator) {
    execEvaluator = 
        Environment.CommandLine
        | ArgLexer.GetTokenInfo
        >^(@(x) x.Value == '-e')
        @.Offset
        @+2
        |> Environment.CommandLine.Substring
        |> parseFunc;
} else {
    execEvaluator = @{};
}

var pattern = remaining[0];

func(path, filter) for (file){
    file = file | io.full;
    var text = file | io.txt;
    var matches = Regex.Matches(text, pattern, reOptions);
    var c = matches#!;

    if (c == 0 ) {
        continue;
    }
    
    var matchHeader =
        '{0} {1} in {2}' :: [
            c,
            'Match' |> c != 1 ? language.pluralize : @(x)x,
            file
        ]
        // |> console.highlight
        // |> console.color.clearResets
        ;
    
    // Console.WriteLine(
    //     '{0}{1}\r\n{2}{3}{4}{5}\r\n',
    //     SystemColor.White | VT100.Background,
    //     console.color.pad(''),
    //     SystemColor.DarkBlue | VT100.Background,
    //     matchHeader,
    //     console.color.pad(matchHeader),
    //     VT100.Reset);    

    
    var excerptFgColor = VT100.Foreground(SystemColor.Cornsilk | console.color.darken);
    var excerptBgColor = VT100.Background(SystemColor.DarkSlateGray | console.color.darken);
    var excerptColor = excerptFgColor + excerptBgColor;
    
    var highlightColor =
        VT100.Foreground(SystemColor.Highlight) +
        VT100.Background(SystemColor.Highlight | console.color.invert);

    matchHeader | console.color.header;
    //matchHeader @+ (100 @seq.init(@(x) x + ':' + (0x41 + x).char().ToString() * 16) |> concat) |> console.color.header;
    Console.WriteLine();

    // ('A' * (Console.BufferWidth + 0 - 5)) + 'foo' | colorHeader;
    // @{%>c:\AAAA\AAAA\AAAA\AAAA\AAAA\AAAA\AAAA\AAAA\AAAA\AAAA\source\Aphid\Components.Aphid\bin\Release64\Library\Meta\Code\Generation\StringEmitter.alx<%}[1].Text @format('{0} {0}') |> colorHeader;
    
    // Console.WriteLine();
    // ('Foo1AAAA AAAA AAAA AAAA AAAA 
    // AAAA AAAA AAAA AAAA AAAA AAAA 
    // BBBBBBBBB 
    // AAAA AAAA AAAA AAAA AAAA
    //  AAAA AAAA AAAA AAAA AAAA '~:'\\s') * 4 |> colorHeader;
// null | dumpe;
    var matchNum = 0;
    var replacements = new List[AphidObject]();
    var updatedOffset = 0;

    matches for (m) {        
        var i2 = 0;
        matchNum++;
        m.Groups ->(@()$_) for (g) {
            if (i2 > 0 && $_.Length == 0) {
                '{0}Capture Group {1}: empty' :: [ groupIndent, i2++ ]
                |> console.highlight
                |> Console.WriteLine;

                if (i2 == (m.Groups#!)) {
                    Console.WriteLine();
                }
                continue;
            }
            var pos = TokenHelper.GetIndexPosition(text, $_.Index);
            var newLen;
            Console.WriteLine('{0}\r\n{1}', 
                ($(i2) 0: 'Match {0}', '{1}Capture Group {2}') +
                ': Line {3:n0}, Column {4:n0}, Index {5:n0}, Length {6:n0}' :: [
                    matchNum,
                    groupIndent,
                    i2,
                    pos.Item1 + 1,
                    pos.Item2 + 1,
                    $_.Index,
                    $_.Length
                ]
                |> console.highlight
                |> console.color.clearResets
                |> (@()format(
                    i2 == 0  ? '{0}{1}{0}{2}{3}' : '{1}',
                    SystemColor.DarkBlue | VT100.Background,
                    $_,
                    new string(' ', Math.Max(0, Console.BufferWidth - 1 - ($_ | console.color.strLen))),
                    VT100.Reset)),
                i2++ == 0 ?
                    TokenHelper
                        .GetCodeExcerpt(
                            text
                                @() [
                                        g.Index | text.Remove |< @() newLen = $_.Length,
                                        highlightColor,
                                        text.Substring(g.Index, g.Length),
                                        excerptColor,
                                        g.Index + g.Length |> text.Substring
                                    ]
                                    | concat,                                
                            newLen,
                            excerptLines)
                        .TrimEnd()
                        .Split(['\r\n'],  StringSplitOptions.None)
                        ->(@(l) '{0}{1}{0}{2}{3}' :: [
                            excerptColor,
                            l,
                            console.color.pad(l),
                            VT100.Reset
                        ])
                        @join('\r\n')
                        @+ '\r\n' :
                    '{0}{1}\r\n' :: [ groupIndent, $_.Value | console.highlight ]);
        };

        var replacement;
        if (useEvaluator) {
            var f = new AphidFunction(execEvaluator.Args, execEvaluator.Body, this);
            replacement = Regex.Replace($_.Groups[0].Value, pattern, f, reOptions);
        } else if (out != null) {
            replacement = Regex.Replace($_.Groups[0].Value, pattern, out, reOptions);
        }

        if (useEvaluator || out != null) {
            replacements.Add({ offset: updatedOffset + $_.Index, len: replacement.Length });
            updatedOffset += replacement.Length - $_.Length;
        }

        if (out != null || useEvaluator) {
            Console.WriteLine('{0}{1}\r\n{0}{2}\r\n',
                groupIndent,
                'Replacement {0}:' :: matchNum |> console.highlight,
                replacement);
        }
    };
//source\aphid\components.aphid\tools\makeexe -f *.alx -s "#.*?std"; -o '/*nostdheader*/' -dump
    if ((matches#!) > 0 && (dumpOut || write) && (useEvaluator || out != null)) {
        var updated;
        
        if (useEvaluator) {
            var f = new AphidFunction(execEvaluator.Args, execEvaluator.Body, this);
            updated = Regex.Replace(text, pattern, f, reOptions);            
        } else if (out != null) {
            updated = Regex.Replace(text, pattern, out, reOptions);
        }

        if (dumpOut) {
            var tmp = updated;
            replacements | reverse for {
                tmp = tmp
                    .Insert($_.offset + $_.len, excerptColor)
                    .Insert($_.offset, highlightColor);
            };
            tmp.Split(['\r\n'],  StringSplitOptions.None) for Console.WriteLine(
                '{0}{1}{0}{2}{3}',
                excerptColor,
                $_,
                console.color.pad($_),                            
                VT100.Reset);

            Console.WriteLine();

        }

        if (write) {
            printInfo('Writing updated text');
            updated |> @io.txt(file);
        }
    }
};