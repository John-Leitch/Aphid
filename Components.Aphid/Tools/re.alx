#'std';
#'system/cryptography';
var memoize = @(argType, retType, func) new ArgLockingMemoizingContainer[argType, retType](func);
#'re.search';
#'re.evaluators';
// #'re.db';

{
    string path: '-p',
    string filter: '-f',
    string excludePattern: '-x',
    bool replace: '-r',    
    bool useEvaluator: '-e',
    bool dumpOut: '-d',
    bool recurse: '-s',
    string out: '-o',
    bool write: '-w',
    int indentSize: '-i',
    int excerptLines: '-l',
    int threads: '-t',
    bool uniqueFiles: '-1',
    int verbosity: '-v',
    bool disableCaptures: '-c-',
    bool bareMode: '-b',
    int bareGroup: '-g',
    bool hashValues: '-hs',
    bool treatAsCode: '-c',
    bool compileAsm: '-asm',
}
| importArgs;

_da = macro(@(n, v) { if (n == null) { n = v } });
_da(filter, '*');
_da(excludePattern, null);
_da(path, '.');
_da(indentSize, 2);
_da(excerptLines, 3);
_da(verbosity, 2);
_da(dumpOut, false);
_da(hashValues, false);

if (out != null) {
    out = out @format('"{0}"') StringParser.Parse;
}

if (bareGroup != null) {
    bareMode = true;
}

if (hashValues && !bareMode) {
    console.error('-hs only supported in bare mode.');
    exit(0xbad52);
}

var toPrintable = @(text, ignoreLines) $_  ~: [
    ignoreLines defined && ignoreLines ?
        '[\\x00-\\x09\\x0b-\\x0c\\x0e-\\x1f\\x7f-\xff]' :
        '[\\x00-\\x1f\\x7f-\xff]',
    '.'
];

var groupIndent = ' ' * indentSize;
var reOptions = RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Multiline;

if (!anyRemaining) {
    SystemColor.DodgerBlue.CopyTo(SystemColor.CadetBlue, 0);
    var hdr = 'Lycomorpha {0}' :: AphidExpression.Assembly.GetName().Version;
    var y;

    if (Environment.UserInteractive) {
        cls();
        y = Console.CursorTop;
    }

    color.header(hdr);    
    print(
        aphid.InitialScope.'$block'
        >$ast.is.text
        |> highlight
        @()$_
            .Split('\n')
            ->(@()$_.Trim().Contains('$R$')?
                $_~:'\\$R\\$'|>color.remove:
                $_)
            @join('\n'));

    if (Environment.UserInteractive) {
        color.glitch.header(hdr, y);
    }

    exit(1);
}

if (verbosity >= 2) {
    console.info('Initializing');
}

var func = recurse ? io.all.files : io.files;
var execEvaluator;

if (useEvaluator) {
    execEvaluator = 
        Environment.CommandLine
        | ArgLexer.GetTokenInfo
        >^(@(x) x.Value == '-e')
        @.Offset
        @+2
        |> Environment.CommandLine.Substring
        |> parseFunc;
} else {
    execEvaluator = @{};
}

var pattern = remaining[0];
var styleEscape = Cli.StyleEscape;

if (!Console.IsInputRedirected) {     
    [ path, filter ]-?io.file->io.full for (f) {        
        path = f | io.up;
        filter = f | io.name;
    };

    var i = 0;
    
    if (verbosity >= 2) {
        console.query('Enumerating files in {0} using filter {1}', path, filter);
    }

    var files = func(path, filter) | toArray;
    var t = files.Length;

    if (verbosity >= 2) {
        console.success('Found {0:n0} files', t);
    }

    var titleBackup = Console.Title;

    files for {
        Console.Title = '({0:n2}%) re' :: (++i / t.double() * 100);
        searchFile($_);
    }
} else {
    console.stdIn.txt() @searchFileText('CONIN$');
}

if (context.list.Count > 0) {
    context.list | dump;
}

exit();
#'re.help';