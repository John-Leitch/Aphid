#'Std';

{
    string path: '-p',
    string filter: '-f',
    bool replace: '-r',    
    bool useEvaluator: '-e',
    bool recurse: '-s',
    string out: '-o',
    bool write: '-w',
    int indentSize: '-t',
}
| console.importArgs;

_da = macro(@(n, v) { if (n == null) { n = v } });
_da(filter, '*');
_da(path, '.');
_da(indentSize, 2);
var groupIndent = ' ' * indentSize;

if (!anyRemaining) {
    print(
        're { -p [path] } { -f [filter] } { -r } { -s } { -o [out str] } ' +
        '{ -t [group indent size] } [pattern]'); // { -e evaluator statements ... }');

    exit(1);
}

var func = recurse ? io.all.files : io.files;
var evaluatorBlock;
var execEvaluator;

if (useEvaluator) {
    evaluatorBlock = 
        Environment.CommandLine
        | ArgLexer.GetTokenInfo
        >^(@(x) x.Value == '-e')
        @.Offset
        @+2
        |> Environment.CommandLine.Substring
        @format('this."$aphid".InitialScope.result = @() {{ {0} }}()');

    execEvaluator = @() AphidEvaluator.Eval(aphid, evaluatorBlock);    
} else {
    execEvaluator = @{};
}

var pattern = remaining[0];

func(path, filter) for (f){
    var text = f | io.txt;
    var matches = text ~~ pattern;
    var c = matches#!;

    if (c == 0 ) {
        continue;
    }
    
    var matchHeader =
        '[ {0} {1} in {2} ]' :: [
            c,
            'Match' |> c != 1 ? language.pluralize : @(x)x,
            f | io.full
        ]
        |> console.highlight
        |> console.color.clearResets;


    
    Console.WriteLine(
        '{0}{1}\r\n{2}{3}{4}{5}\r\n',
        SystemColor.White | VT100.Background,
        console.color.pad(''),
        SystemColor.DarkBlue | VT100.Background,
        matchHeader,
        console.color.pad(matchHeader),
        VT100.Reset);    

    var matchNum = 0;
    matches for (m) {        
        var i2 = 0;        
        m.Groups ->(@()$_) for (g) {
            if (i2 > 0 && $_.Length == 0) {
                '{0}Capture Group {1}: empty' :: [ groupIndent, i2++ ]
                |> console.highlight
                |> Console.WriteLine;

                if (i2 == (m.Groups#!)) {
                    Console.WriteLine();
                }
                continue;
            }
            var pos = TokenHelper.GetIndexPosition(text, $_.Index);
            var newLen;
            Console.WriteLine('{0}\r\n{1}', 
                ($(i2) 0: 'Match {0}', '{1}Capture Group {2}') +
                ': Line {3:n0}, Column {4:n0}, Index {5:n0}, Length {6:n0}' :: [
                    ++matchNum,
                    groupIndent,
                    i2,
                    pos.Item1 + 1,
                    pos.Item2 + 1,
                    $_.Index,
                    $_.Length
                ]
                |> console.highlight
                |> console.color.clearResets
                |> (@()format(
                    i2 == 0  ? '{0}{1}{0}{2}{3}' : '{1}',
                    SystemColor.DarkBlue | VT100.Background,
                    $_,
                    new string(' ', Math.Max(0, Console.BufferWidth - 1 - ($_ | console.color.strLen))),
                    VT100.Reset)),
                i2++ == 0 ?
                    TokenHelper
                        .GetCodeExcerpt(
                            text
                                @() [
                                        g.Index | text.Remove | console.highlight |< @() newLen = $_.Length,
                                        
                                        text
                                            .Substring(g.Index, g.Length)
                                            |> SyntaxHighlightingFormatter.Highlight
                                            -> console.color.invertText
                                            -> VT100.GetString
                                            |> concat,

                                        g.Index + g.Length |> text.Substring |> console.highlight
                                    ]
                                    | concat,                                
                            newLen,
                            3)
                        .TrimEnd()
                        .Split(['\r\n'],  StringSplitOptions.None)
                        ->(@() '{0}{1}{0}{2}{3}' :: [
                            VT100.Background(SystemColor.DarkSlateGray->@()Math.Max(0, $_- 0x30).byte()),
                            $_ | console.color.clearResets,
                            new string(' ', Math.Max(0, Console.BufferWidth - ($_ | console.color.remove @.Length) - 1)),
                            VT100.Reset
                        ])
                        @join('\r\n')
                        @+ '\r\n' :
                    '{0}{1}\r\n' :: [ groupIndent, $_.Value ]);
        };

        if (out != null) {
            Console.WriteLine('{0}\r\n{1}\r\n', 
                'Updated:' |> console.highlight,
                $_.Groups[0].Value ~: [ pattern, out ]);
        }
    };

    if ((matches#!) > 0 && (useEvaluator|| write)) {
        var updated = text ~: [ pattern, out ];
        
        if (useEvaluator) {
            printInfo('Running evaluator');
            
            execEvaluator();
            if (result defined && result != null) {
                Console.WriteLine(
                    '{0}\r\n{1}\r\n', 
                    'Evaluator:' |> console.highlight,
                    result);
                // printSuccess('Evaluator updated value:\r\n{0}', result);
                updated = result;
            }
        }

        if (write) {
            printInfo('Writing updated text');
            updated |> @io.txt(f);
        }
    }
};