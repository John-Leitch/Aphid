this @mix(console);

var searchFile = @(file) {    
    if (excludePattern != null && Regex.IsMatch(file, excludePattern, reOptions)) {
        if (verbosity >= 4) {
            info('Skipping ~Yellow~{0}~R~ due to exclude pattern', file | styleEscape);
        }
        continue;
    }

    if (verbosity >= 3) {
        info('Searching {0}', file | styleEscape);
    }

    var text;

    try {
        file = file | io.full;
        text = file | io.txt;
    } catch (e) {
        fail('Could not read file: {0}', e.message | styleEscape);
        continue;
    }

    searchFileText(file, text);
};

var getMatchValue = @() bareGroup == null ? $_.Value : $_.Groups[bareGroup].Value;


var theme;
var excerptColor;
var highlightColor;

var initTheme = @{
    theme = {
        excerpt: { fg: SystemColor.Cornsilk | color.darken, bg: SystemColor.DarkSlateGray | color.darken },
        highlight: { fg: SystemColor.Highlight, bg: SystemColor.Highlight | color.invert },
    };

    if (treatAsCode) {
        theme.excerpt.bg = [0x10.byte(),0x10.byte(),0x10.byte()];
        theme.excerpt.bg = SystemColor.DarkYellow | darken;
    }

    excerptColor = color.pair(theme.excerpt.fg, theme.excerpt.bg);
    highlightColor = color.pair(theme.highlight.fg, theme.highlight.bg);
};

// theme.darken.Keys
// -?theme.darken.get_Item
// for (t) [ 'fg', 'bg' ] for theme[t][$_] = theme[t][$_] | color.darken;





var searchFileText = @(file, text) {
    if (theme == null) {
        initTheme();
    }

    var matches = Regex.Matches(text, pattern, reOptions);
    var c = matches#!;

    if (c == 0) {
        continue;
    }

    if (bareMode) {
        if (!useEvaluator) {
            _walkMatches = macro(@(f) { matches for $_ | getMatchValue | f });
            if (verbosity >= 1) {
                if (hashValues) {
                    _walkMatches(hash);
                } else {
                    _walkMatches(console.line);
                }                
            } else if (hashValues) {
                _walkMatches(context.hashed.Add);                
            }
        } else {
            matches for (m) {
                var value = m | getMatchValue;
                var f = new AphidFunction(execEvaluator.Args, execEvaluator.Body, this);
                f();
            }
        }
        
        continue;
    }

    if (verbosity >= 2) {
        '{0} {1} in {2}' :: [ c, 'Match' |> c != 1 ? language.pluralize : @(x)x, file | styleEscape ]
        |> color.header;
        console.line();
    }

    var matchNum = 0;
    var replacements = new List[AphidObject]();
    var updatedOffset = 0;
    var displayText = null;

    matches for (m) {        
        var i2 = 0;
        matchNum++;

        if (verbosity >= 1) {
            m.Groups for (g) {
                if (i2 > 0) {                
                    if (disableCaptures || verbosity < 2) {
                        continue;
                    } else if ($_.Length == 0) {
                        '{0}Capture Group {1}: empty' :: [ groupIndent, i2++ ]
                        |> code;

                        if (i2 == (m.Groups#!)) {
                            console.line();
                        }
                        continue;
                    }
                }

                if (displayText == null && excerptLines > -1) {
                    displayText = toPrintable(text, true);
                    
                    if (treatAsCode) {
                        displayText = displayText | console.highlight;
                    }
                }

                printMatchGroup(displayText, g, i2, matchNum);

                
            };
        }

        var replacement;
        if (useEvaluator) {
            var f = new AphidFunction(execEvaluator.Args, execEvaluator.Body, this);
            replacement = Regex.Replace($_.Groups[0].Value, pattern, f, reOptions);
        } else if (out != null) {
            replacement = Regex.Replace($_.Groups[0].Value, pattern, out, reOptions);
        }

        if (useEvaluator || out != null) {
            replacements.Add({ offset: updatedOffset + $_.Index, len: replacement.Length });
            updatedOffset += replacement.Length - $_.Length;
        }

        if ((out != null || useEvaluator) && verbosity >= 2) {
            console.line('{0}{1}\r\n{0}{2}\r\n',
                groupIndent,
                'Replacement {0}:' :: matchNum |> highlight,
                replacement);
        }
    };

    if ((matches#!) > 0 && (dumpOut || write) && (useEvaluator || out != null)) {
        var updated;
        
        if (useEvaluator) {
            var f = new AphidFunction(execEvaluator.Args, execEvaluator.Body, this);
            updated = Regex.Replace(text, pattern, f, reOptions);            
        } else if (out != null) {
            updated = Regex.Replace(text, pattern, out, reOptions);
        }

        if (dumpOut) {
            var tmp = updated;

            replacements | reverse for {
                tmp = tmp
                    .Insert($_.offset + $_.len, excerptColor)
                    .Insert($_.offset, highlightColor);
            };

            tmp.Split(['\r\n'],  StringSplitOptions.None) for console.line(
                '{0}{1}{0}{2}{3}',
                excerptColor,
                $_ | toPrintable,
                color.pad($_),                            
                VT100.Reset);

            console.line();
        }

        if (write) {
            if (verbosity >= 2) {
                printInfo('Writing updated text');
            }
            
            updated |> @io.txt(file);
        }
    }
};

var printMatchGroup = @(displayText, g, i2, matchNum) {
    var pos = TokenHelper.GetIndexPosition(displayText, g.Index);
    _pi = macro(@(n) { (pos != null ? pos.n + 1 : 'Error calculating position') });
    var newLen;

    console.line('{0}\r\n{1}', 
        ($(i2) 0: 'Match {0}', '{1}Capture Group {2}') +
        ': Line {3:n0}, Column {4:n0}, Index {5:n0}, Length {6:n0}' :: [
            matchNum,
            groupIndent,
            i2,
            _pi(Item1),
            _pi(Item2),
            g.Index,
            g.Length
        ]
        |> highlight                
        |> (@()format(
            i2 == 0  ? '{0}{1}{0}{2}{3}' : '{1}',
            SystemColor.DarkBlue | VT100.Background,
            $_,
            new string(' ', Math.Max(0, Console.BufferWidth - 1 - ($_ | color.strLen))),
            VT100.Reset)),
        i2++ == 0 && excerptLines > -1 ?
            TokenHelper
                .GetCodeExcerpt(
                    displayText.Insert(g.Index + g.Length, excerptColor).Insert(g.Index, highlightColor),
                    g.Index + highlightColor.Length,
                    excerptLines)
                .TrimEnd()
                .Split(['\r\n'],  StringSplitOptions.None)
                ->(@(l) '{0}{1}{0}{2}{3}' :: [
                    excerptColor,
                    l,
                    color.pad(l),
                    VT100.Reset
                ])
                @join('\r\n')
                @+ '\r\n' :
            '{0}{1}{2}\r\n' :: [ groupIndent, toPrintable(g.Value, true) | highlight, VT100.Reset ]);
};